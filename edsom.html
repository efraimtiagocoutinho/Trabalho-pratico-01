<!DOCTYPE HTML>
<html>
<head>
		 
			<title>Historia do git  </title>
				</head>
				<body meta charset="UTF-8" align="center" bgcolor="green">
				<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
			 <hgroup>
			<h2> <p> uma breve historia do git </p> <h2>
			 </hgroup>
			
		<font align="justin" color="#333333" >
		<style> p.linhaB { line-height: 10px; } </style>
<p class="linhaB">
			
			<h2> 
			
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  
			assim como muitas coisas boas na vida, o Git começou com um tanto de destruição criativa e controvérsia acirrada. 
			O kernel (núcleo) do Linux é um projeto de software de código aberto de escopo razoavelmente grande. Durante a maior parte do período de manutenção do kernel do Linux (1991-2002), 
			as mudanças no software eram repassadas como patches e arquivos compactados. Em 2002, 
			o projeto do kernel do Linux começou a usar um sistema DVCS proprietário chamado BitKeeper.

Em 2005, o relacionamento entre a comunidade que desenvolvia o kernel e a empresa que desenvolvia comercialmente o BitKeeper se desfez, 
e o status de isento-de-pagamento da ferramenta foi revogado. Isso levou a comunidade de desenvolvedores do Linux (em particular Linus Torvalds,
 o criador do Linux) a desenvolver sua própria ferramenta baseada nas lições que eles aprenderam ao usar o BitKeeper. Alguns dos objetivos do novo sistema eram:


<br align="LEFT">Velocidade </br>
<br>Design simples</br>
<br>Suporte robusto a desenvolvimento não linear (milhares de branches paralelos) </br>
<br>Totalmente distribuído</br>
Capaz de lidar eficientemente com grandes projetos como o kernel do Linux (velocidade e volume de dados)
Desde sua concepção em 2005, o Git evoluiu e amadureceu a ponto de ser um sistema fácil de usar e ainda assim mantém essas qualidades iniciais.
 É incrivelmente rápido, bastante eficiente com grandes projetos e possui um sistema impressionante de branching para desenvolvimento não-linear.

 </h2>	<font align="justin" color="black" >
 	<h2> <p> criadores do git </p> <h2>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O desenvolvedor inicial do Git foi Linus Torvalds (criador do Linux).
Um sistema de controle de versão tem a finalidade de gerenciar as diferentes versões de um documento. É muito utilizado por empresas de desenvolvimento de software que possuem grandes equipes e precisam manter organizado, documentado e arquivado tudo o que foi e está sendo implementado no software.
Como exemplo de projetos que utilizam o Git temos: Arch Linux, Android, Debian, Digg, Eclipse, Fedora, GNOME, jQuery, openSUSE, Ruby on Rails, Samba, Yahoo UI Library, entre outros.
 
 </h2>	<font align="justin" color="#333333" >
 	<h2> <p> FUNCIONALIDADES DO GIT  </p> <h2>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>O que é Git e os fundamentos de como ele funciona, será muito mais fácil utilizá-lo de forma efetiva.</br> À medida que você aprende a usar o Git, tente não pensar no que você já sabe sobre outros VCSs como Subversion e Perforce; assim você consegue escapar de pequenas confusões que podem surgir ao usar a ferramenta. Apesar de possuir uma interface parecida, o Git armazena e pensa sobre informação de uma forma totalmente diferente desses outros sistemas; entender essas diferenças lhe ajudará a não ficar confuso ao utilizá-lo.

Snapshots, E Não Diferenças
<br>A maior diferença entre Git e qualquer outro VCS (Subversion e similares inclusos) está na forma que o Git trata os dados. Conceitualmente, a maior parte dos outros sistemas armazena informação como uma lista de mudanças por arquivo. Esses sistemas (CVS, Subversion, Perforce, Bazaar, etc.) tratam a informação que mantém como um conjunto de arquivos e as mudanças feitas a cada arquivo ao longo do tempo, conforme ilustrado na Figura 1.4.


ne ou sem acesso a uma VPN.</br> Se você entrar em um avião ou trem e quiser trabalhar, você pode fazer commits livre de preocupações até ter acesso a rede novamente para fazer upload. Se você estiver indo para casa e seu cliente de VPN não estiver funcionando, você ainda pode trabalhar. Em outros sistemas, fazer isso é impossível ou muito trabalhoso. No Perforce, por exemplo, você não pode fazer muita coisa quando não está conectado ao servidor; e no Subversion e CVS, você pode até editar os arquivos, mas não pode fazer commits das mudanças já que sua base de dados está offline. Pode até parecer que não é grande coisa, mas você pode se surpreender com a grande diferença que pode fazer.
 </p> <br /> </p>
  </h2>	<font align="justin" color="black" >
 	<h2> <p> comandos git </p> </h2>
  </h2>	<font align="justin" color="black" >
 	Primeiros Passos

<br><h3>Configurando informações sobre o autor dos commits:<br><h3>

<br>git config --global user.name "Gustavo"
git config --global user.email "gustavo@gustavohenrique.net"
É possível alterar essas informações no arquivo ~/.gitconfig

Criando um repositório local:

cd meuprojeto
git init
Para ter certeza que o repositório foi criado:
</br>
<br>git status</br>
Áreas de Trabalho

<br>O git possui 4 áreas de trabalho:
1. O diretório .git que é o repositório contendo todos os arquivos versionados;
2. Working Area que é um snapshot do .git dentro de um determinado momento no tempo;
3. Stage que é um local temporário que armazena a referência para arquivos a serem versionados antes de serem commitados;
4. Stash que também é um local temporário que pode armazenar e esconder arquivos que estão no Stage.
</br>
<br>Adicionando arquivos novos ou modificados no Stage:</br>
<br>
git add arquivo.txt
git add *.py
git add . (para add todos os arquivos)
git add -i (para modo interativo. 1-5 ou 1,2,3,4 e -3 para retirar)
Removendo arquivos não versionados do Stage:
</br>
<br>
git rm --cached arquivo.txt
git clean -fd (remove todos arquivos e diretórios)
Removendo arquivos versionados e modificados do Stage:

git reset HEAD arquivo.txt
git reset HEAD (todos os arquivos)
Desfazendo modificações de arquivos versionados no Stage:

git checkout -- arquivo.txt
Trabalhando com o Stash:
<br>
git stash (Move todos os arquivos do Stage para o Stash)
git stash save "Mensagem" (Move todos os arquivos do Stage para o Stash e os identifica com uma mensagem)
git stash list
git stash apply (Recupera os arquivos do último Stash de volta para o Stage mantendo cópia no Stash)
git stash apply < ID > (Recupera os arquivos do Stash identificado pelo ID obtido pelo git stash list. Ex.: stash@{0})
git stash pop (Faz o mesmo que apply porém apaga os arquivos do Stash)
git stash drop < ID> (Apaga completamente o Stash)
git fsck --unreachable | grep commit (Recupera arquivos apagados do Stash)
Commits
</br>
Apenas arquivos no Stage podem ser commitados.
<br>
git commit -m "Mensagem"
git commit -a -m "Mensagem" (commita também os arquivos versionados mesmo nao estando no Stage)
Refazendo commit quando esquecer de adicionar um arquivo no Stage:
</br>
git add arquivo.txt
git commit -m "Mensagem" --amend
O amend é destrutivo e só deve ser utilizado antes do commit ter sido enviado ao servidor remoto.

<br>Voltando commits anteriores:</br>

<br>git reset --hard HEAD~1 (volta ao último commit)</br>
git reset --soft HEAD~1 (volta ao último commit e mantém os últimos arquivos no Stage)</br>
<br>
<br>git reset --hard XXXXXXXXXXX (Volta para o commit com a hash XXXXXXXXXXX)
Recuperando commit apagado pelo git reset:</br>

<br>git reflog (Para visualizar os hashs)</br>
git merge <hash>
Logs

</br>Visualizando logs:<br>

git log
git log --stat (Mostra o que foi modificado em cada commit)
git log --graph (Mostra gráfico do log)
git log --pretty=oneline (Mostra os commits linha por linha)
git log --pretty=format:"%an %ad %h %s" (Exibe o autor, data, sha1 abreviado e texto do commit)
git log --since=30.minutes ou 1.hour ou 2.hours (Exibe commits dos últimos 30 minutos, 1h ou 2h)
git log --since=10.hours --until=2.hours (Exibe commits entre as últimas 10h e últimas 2h)
git log --before="2010-12-25" (Exibe commits antes do dia 25/12/2010)
git reflog (Mostra commits apagados pelo git reset)
<br>Branches</br>

<br>Cada branch deve ter uma única funcionalidade. É recomendado criar um novo branch a partir do master e aplicar os merges nele para efeito de simulação.
</br>
<br>git branch (Lista os branches)</br>
<br>git branch -a (Mostra também os branches do repositório remoto)</br>
<br>git branch -d novobranch (Apaga o branch)</br>
<br>git branch -D novobranch (Força a remoção do branch)</br>
<br>git checkout -b novobranch (Cria um branch contendo os mesmos commits do branch de origem)</br>
<br>git checkout -b novobranch origin/outrobranch (Cria novobranch a partir do outrobranch no repositório remoto)</br>
<br>git checkout -b [branch, tag, sha1]</br>
<br>git checkout -b <branch> v1.0 (Cria um branch a partir da tag v1.0)</br>
<br>git checkout master (Retorna ao branch master)</br>
<br>git rebase master (Atualiza um branch com o que há de novo no master)</br>
<br>git merge novobranch (Faz um merge do que foi feito em novobranch)</br>
<br>git merge novobranch --squash (Permite definir uma nova mensagem em vez das mensagens de todos os commits do novobranch)
Conflitos</br>

<br>Quanto mais tempo demorar para atualizar um branch a partir do master (git rebase), maior será a chance de haver conflitos depois.
O rebase é destrutivo, se estiver trabalhando em um servidor remoto deve usar o merge.</br>

<br>git rebase --skip (Perde o arquivo novo)</br>
<br>git rebase --abort (Cancela o rebase)</br>
<br>git rebase --continue (Para continuar após lidar com o conflito manualmente)
Repositórios</br>

Clonando repositórios:

<br>git clone repo1 repo2 (Clona um repositório e add o repo1 como orign no repo2)</br>
<br>git remote show origin (Origin é uma convenção para o primeiro remote)</br>
<br>git push origin (Envia o commit local para o repositório remoto)</br>
<br>git push origin outrobranch (O mesmo acima mas para um determinado branch)</br>
</br>git remote add origin repo (Adiciona um repositório como remoto)<br>
<br>git pull (Atualiza a partir do repositório remoto)</br>
<br>git pull origin outrobranch (O mesmo acima mas a partir de um determinado branch)</br>
<br>git remote rm origin (Remove o repositório remoto)</br>
<br>Trabalhando como repositórios remotos:</br>
<br>Antes de dar um git push, dar um git fecth e um git rebase para não criar conflitos para outros usuários.</br>

<br>git init --bare (Cria um repositório sem área de trabalho)</br>
<br>git fetch origin (Puxa novos commits do repositório remoto)</br>
git fetch remote <branch> (Puxa novos commits do repositório remoto para o branch)
git push origin <branch> (Envia o que está no branch atual para o branch no repositório remoto)
git push origin v1.0 (Envia a tag v1.0)
<br>git pull (Atualiza o repositório local a partir do remoto. Similar a usar "fecth" + "merge")
git pull origin <branch> (Atualiza o branch local a partir do branch remoto)
Github</br>

<br>Criando seu próprio projeto:</br>
<br>Crie um projeto pelo site do github. Em seguida, na máquina local, crie um par de chaves pública e privada, copie e cole no campo apropriado no github.

ssh-keygen -trsa</br>
Depois copiar o conteudo de ~/.ssh/id_rsa.pub e colar na página do github.

<br>Fazendo um fork de um projeto:
Faça um fork de um repositório, um clone para sua máquina, altere o código, commit e no site clique no link “pull request”. O dono do repositório original deve adicionar a URL do repositório fork com git remote add usuario urlfork. Depois executar um git fecth para trazer os branches do fork. Usar git diff usuario/ para ver as alterações. Para aceitar, git merge (resolver conflitos caso apareça), criar um novo commit e enviar com o git push. O usuário que fez o fork deve executar o mesmo procedimentos para manter o fork sincronizado com o repositório original.
</br>
Patches

<br>Trabalhando com patches:<br>

<br>git format-patch <branch> --stdout > patch.diff (Cria um patch)</br>
git am patch.diff (Aplica o patch)
Tags

<br>Uma tag é utilizada para criar uma versão de lançamento.</br>

<br>git tag v1.0 (Cria a tag v1.0)</br>
git push origin v1.0 (Envia a tag v1.0)
git push --tags (Envia todas as tags)
git checkout -b <branch> v1.0 (Cria um branch a partir da tag v1.0)
git-svn

Lidando com svn:

git svn clone svn://repo (Clona um repositorio svn)
git svn clone -r10:HEAD URL NOME (clone de um intervalo de revisões svn)
git svn dcommit (Envia commit para o repositório svn)
git svn fecth (Atualiza a partir do repositório svn)
Links

http://git-scm.com/
http://www.kernel.org/pub/software/scm/git/docs/


MARCH 12, 2011GIT, LINUXGIT, GITHUBGUST
</br>
	
			<body>
			
<body/>
<html/>